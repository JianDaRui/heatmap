<!--
    THIS EXAMPLE WAS DOWNLOADED FROM https://echarts.apache.org/examples/zh/editor.html?c=heatmap-large
-->
<!DOCTYPE html>
<html style="height: 100%">

<head>
  <meta charset="utf-8">
</head>

<body style="height: 100%; margin: 0">
  <div id="container" style="height: 100%"></div>
  <script src="https://unpkg.com/vue@next"></script>
  <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
  <!-- 导入组件库 -->
  <script src="https://unpkg.com/element-plus"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5.3.1/dist/echarts.min.js"></script>
  <script type="text/javascript"
    src="https://cdn.jsdelivr.net/npm/echarts@5.3.1/dist/extension/dataTool.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-stat@latest/dist/ecStat.min.js"></script>
  <script type="text/javascript">

    function floor(value) {
      return Math.floor(value)
    }

    function GeneratePoints(width, height, row = 3, column = 3, pointGap = 20) {
      this.width = width
      this.height = height
      this.row = row
      this.column = column
      this.pointGap = pointGap
      this.vector = [
        [pointGap, 0],
        [pointGap, pointGap],
        [0, pointGap],
        [-pointGap, pointGap],
        [-pointGap, 0],
        [-pointGap, -pointGap],
        [0, -pointGap],
        [pointGap, -pointGap]
      ]
      this.xAxisGap = floor(width / (column + 1))
      this.yAxisGap = floor(height / (row + 1))

      this.pointsOrigin = []
      this.data = []
    }

    GeneratePoints.prototype.init = function () {
      for (let r = 1; r <= this.row; r++) {
        let colArr = []
        for (let c = 1; c <= this.column; c++) {
          colArr.push({
            x: this.xAxisGap * c,
            y: this.yAxisGap * r,
            value: floor(Math.random() * 100),
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            // radius: 100
          })
        }
        this.pointsOrigin.push(colArr)
      }
    }
    // 右边的点到左边的点的距离
    // 用于确定右边点的left,左边点的right
    GeneratePoints.prototype._rightToLeftBoundary = function (currentPoint, leftPoint) {
      const leftDistance = currentPoint.x - leftPoint.x
      const leftTotal = currentPoint.value + leftPoint.value
      const leftScale = (currentPoint.value / leftTotal) * leftDistance
      currentPoint.left = floor(currentPoint.x - leftScale)
      leftPoint.right = floor(leftPoint.x + leftDistance - leftScale)
    }
    // 底部的点到顶部的点的距离
    // 用于确定底部点的top, 顶部点的bottom
    GeneratePoints.prototype._bottomToTopBoundary = function (currentPoint, topPoint) {
      const topDistance = currentPoint.y - topPoint.y
      const topTotal = currentPoint.value + topPoint.value
      const topScale = (currentPoint.value / topTotal) * topDistance

      currentPoint.top = floor(currentPoint.y - topScale)
      topPoint.bottom = floor(topPoint.y + topDistance - topScale)
    }

    GeneratePoints.prototype.computedBoundary = function () {
      // 计算外边 上下边界
      for (let c = 0; c < this.column; c++) {
        this.pointsOrigin[0][c].top = 0
        this.pointsOrigin[this.row - 1][c].bottom = this.height
        // 最后一排的上边界
        // const 
        this._bottomToTopBoundary(this.pointsOrigin[this.row - 1][c], this.pointsOrigin[this.row - 2][c])
        if (c > 0) {
          this._rightToLeftBoundary(this.pointsOrigin[0][c], this.pointsOrigin[0][c - 1])
          this._rightToLeftBoundary(this.pointsOrigin[this.row - 1][c], this.pointsOrigin[this.row - 1][c - 1])
        }
      }

      // 计算外边 左右边界
      for (let r = 0; r < this.row; r++) {
        this.pointsOrigin[r][0].left = 0
        this.pointsOrigin[r][this.column - 1].right = this.width
        // 最后一列的左边界
        // const 
        this._rightToLeftBoundary(this.pointsOrigin[r][this.column - 1], this.pointsOrigin[r][this.column - 2])
        if (r > 0) {
          this._bottomToTopBoundary(this.pointsOrigin[r][0], this.pointsOrigin[r - 1][0])
          this._bottomToTopBoundary(this.pointsOrigin[r][this.column - 1], this.pointsOrigin[r - 1][this.column - 1])
        }
      }
      /**
       * 计算内部点的上下左右边界
       * 上下左右边界的距离为
       * 相同方向上点的value占比 * 两点之间同方向的距离
       * 
       */
      for (let r = 1; r < this.row - 1; r++) {
        for (let c = 1; c < this.column - 1; c++) {
          // top
          this._bottomToTopBoundary(this.pointsOrigin[r][c], this.pointsOrigin[r - 1][c])
          // left 
          this._rightToLeftBoundary(this.pointsOrigin[r][c], this.pointsOrigin[r][c - 1])
        }
      }
    }
    // 用于计算根据每个原始点的dfs
    GeneratePoints.prototype.perOriginPointDfs = function () {
      let points = this.pointsOrigin.flat().sort((p1, p2) => p1.value - p2.value)
      while (points.length) {
        let point = points.pop()
        this._bfs(point)
      }
      return this.data
    }

    GeneratePoints.prototype._bfs = function (currentPoint) {
      const {
        value: initValue,
        left: leftBoundary,
        right: rightBoundary,
        top: topBoundary,
        bottom: bottomBoundary
      } = currentPoint
      const queue = [currentPoint]

      const vector = this.vector
      const data = this.data
      // const data = []
      data.push(currentPoint)
      const memo = {}

      while (queue.length) {
        const point = queue.pop()
        for (let v of vector) {
          let x = point.x + v[0]
          let y = point.y + v[1]
          let key = x + '_' + y
          if (memo[key]) continue
          let value = point.value
          if (x >= leftBoundary && x <= rightBoundary && y >= topBoundary && y <= bottomBoundary) {
            memo[key] = true
            data.push({
              x: x,
              y: y,
              value: value - Math.random(), //noise.perlin2(value / 100, value / 100) + 0.5,
              // radius: Math.abs(floor(value / 50) * 100)
            })
            queue.push({
              x: x,
              y: y,
              value: value -  Math.random(), // noise.perlin2(value / 100, value / 100) + 0.5
            })
          }
        }
      }
      // console.log(currentPoint, data)
      // return this.data.push(data)
    }
    
    let width = (+window.getComputedStyle(document.body).width.replace(/px/, ''))
    let height = (+window.getComputedStyle(document.body).height.replace(/px/, ''))

    let instance = new GeneratePoints(width, height, 5, 5, 5)
    let noise = getNoiseHelper();
    instance.init()
    instance.computedBoundary()
    instance.perOriginPointDfs()
    console.log(instance.pointsOrigin, instance.data)


    var dom = document.getElementById("container");
    var myChart = echarts.init(dom);
    var app = {};
    var option;
    // let noise = getNoiseHelper();
    let xData = [];
    let yData = [];
    let random = Math.random()
    noise.seed(random * 1000);
    // 生成数据
    function generateData(theta, min, max) {
      let data = [];
      // for (let i = 0; i <= 300; i++) {
      //   for (let j = 0; j <= 300; j++) {
      //     // let x = (max - min) * i / 200 + min;
      //     // let y = (max - min) * j / 100 + min;
      //     data.push([i, j, noise.perlin2(i / 200, j / 200) + 50]); 
      //   } 
      // }
      const allPoints = instance.data
      let maxVal = -1000
      let minVal = 1000
      for(let i = 0, len = allPoints.length; i < len; i++) {
        maxVal = allPoints.value > maxVal ? allPoints.value : maxVal
        minVal = allPoints.value < minVal ? allPoints.value : minVal
        data.push([allPoints[i].x, allPoints[i].y, noise.perlin2(allPoints[i].x/300, allPoints[i].y/300) + allPoints[i].value * Math.random()])
      }
      console.log(maxVal, minVal)
      data.sort((a, b) => {
        if(a.x - b.x > 0) {
          return true
        } else if(a.x - b.x < 0) {
          return false
        } else {
          return a.y - b.y
        }
      })
      return data;
    }
    let data = generateData();
    // 配置项
    option = {
      tooltip: {
        show: false
      },
      grid: {
        top: 0,
        bott0m: 0,
        right: 0,
        left: 0,
        width: '100%',
        height: '100%'
      },
      xAxis: {
        show: false
      },
      yAxis: {
        show: false
      },
      visualMap: {
        type: 'continuous',
        orient: 'horizontal',
        right: 30,
        min: 0,
        max: 10,
        calculable: true,
        realtime: false,
        inRange: {
          // color: ['#4575b4', '#74add1', 'green', 'yellow', 'red'],
          color: [
            '#313695',
            '#4575b4',
            '#74add1',
            '#abd9e9',
            '#e0f3f8',
            '#ffffbf',
            '#fee090',
            '#fdae61',
            '#f46d43',
            '#d73027',
            '#a50026'
          ]
        }
      },
      series: [
        {
          name: '温度',
          type: 'heatmap',
          data: data,
          coordinateSystem: 'cartesian2d',
          emphasis: {
            itemStyle: {
              borderColor: 'green',
              borderWidth: 10
            }
          },
          itemStyle: {
            opatity: 0.8,
            borderJoin: 'butt',
            shadowBlur: 100,
            opacity: 0.8,
            // color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
            borderCap: 'round',
            // borderRadius: [1, 0, 0, 1]
          },
          progressive: 9000,
          progressiveThreshold: 10000,
          animation: false
        }
      ]
    };

    function getNoiseHelper() {
      class Grad {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        dot2(x, y) {
          return this.x * x + this.y * y;
        }
        dot3(x, y, z) {
          return this.x * x + this.y * y + this.z * z;
        }
      }
      const grad3 = [
        new Grad(1, 1, 0),
        new Grad(-1, 1, 0),
        new Grad(1, -1, 0),
        new Grad(-1, -1, 0),
        new Grad(1, 0, 1),
        new Grad(-1, 0, 1),
        new Grad(1, 0, -1),
        new Grad(-1, 0, -1),
        new Grad(0, 1, 1),
        new Grad(0, -1, 1),
        new Grad(0, 1, -1),
        new Grad(0, -1, -1)
      ];
      const p = [
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
        36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
        234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
        88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
        134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
        230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
        1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
        116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
        124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
        47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
        154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
        108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
        239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
        50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
        141, 128, 195, 78, 66, 215, 61, 156, 180
      ];
      // To remove the need for index wrapping, double the permutation table length
      let perm = new Array(512);
      let gradP = new Array(512);
      // This isn't a very good seeding function, but it works ok. It supports 2^16
      // different seed values. Write something better if you need more seeds.
      function seed(seed) {
        if (seed > 0 && seed < 1) {
          // Scale the seed out
          seed *= 65536;
        }
        seed = Math.floor(seed);
        if (seed < 256) {
          seed |= seed << 8;
        }
        for (let i = 0; i < 256; i++) {
          let v;
          if (i & 1) {
            v = p[i] ^ (seed & 255);
          } else {
            v = p[i] ^ ((seed >> 8) & 255);
          }
          perm[i] = perm[i + 256] = v;
          gradP[i] = gradP[i + 256] = grad3[v % 12];
        }
      }
      seed(0);
      // ##### Perlin noise stuff
      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }
      function lerp(a, b, t) {
        return (1 - t) * a + t * b;
      }
      // 2D Perlin Noise
      function perlin2(x, y) {
        // Find unit grid cell containing point
        let X = Math.floor(x),
          Y = Math.floor(y);
        // Get relative xy coordinates of point within that cell
        x = x - X;
        y = y - Y;
        // Wrap the integer cells at 255 (smaller integer period can be introduced here)
        X = X & 255;
        Y = Y & 255;
        // Calculate noise contributions from each of the four corners
        let n00 = gradP[X + perm[Y]].dot2(x, y);
        let n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
        let n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
        let n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);
        // Compute the fade curve value for x
        let u = fade(x);
        // Interpolate the four results
        return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
      }

      return {
        seed,
        perlin2
      };
    }

    if (option && typeof option === 'object') {
      myChart.setOption(option);
    }

  </script>
</body>

</html>