<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>HeapMap</title>
  <script src="https://unpkg.com/vue@next"></script>
  <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
  <!-- 导入组件库 -->
  <script src="https://unpkg.com/element-plus"></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: sans-serif;
    }

    body * {
      font-weight: 200;
    }

    #app {
      width: 100%;
      height: 100%;
      position: absolute;
      background: rgba(0, 0, 0, .1);
    }

    #heatmapContainer {
      width: 100%;
      height: 100%;
    }

    .footer {
      background: white;
      position: absolute;
      bottom: 0;
      right: 0;
      padding: 10px;
    }

    .min {
      float: left;
    }

    .max {
      float: right;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="heatmapContainer" ref="heatMapContainer">
    </div>
    <!-- footer -->
    <el-card class="footer" ref="footer" shadow="never">
      <div>数据映射</div>
      <span class="min" ref="minRef"></span>
      <span class="max" ref="maxRef"></span>
      <img class="gradient" ref="gradientRef" src="" style="width:100%" />
      <el-button type="primary" size="small" @click="handlerInput">输入</el-button>
    </el-card>

    <!-- 输入对话框 -->
    <el-dialog v-model="dialogInput" width="45%" title="数据录入">
      <!-- 桌面大小 -->
      <el-form :model="rectInfo">
        <el-row>
          <el-form-item label="宽" :label-width="formLabelWidth">
            <el-input v-model="rectInfo.width" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="高" :label-width="formLabelWidth">
            <el-input v-model="rectInfo.height" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
        </el-row>
      </el-form>
      <!-- 数据表单 -->
      <el-form :model="form">
        <el-row :gutter="1">
          <el-form-item label="value1" :label-width="formLabelWidth">
            <el-input v-model="form[0].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value2" :label-width="formLabelWidth">
            <el-input v-model="form[1].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value3" :label-width="formLabelWidth">
            <el-input v-model="form[2].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
        </el-row>
        <el-row :gutter="2">
          <el-form-item label="value4" :label-width="formLabelWidth">
            <el-input v-model="form[3].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value5" :label-width="formLabelWidth">
            <el-input v-model="form[4].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value6" :label-width="formLabelWidth">
            <el-input v-model="form[5].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
        </el-row>
        <el-row :gutter="2">
          <el-form-item label="value8" :label-width="formLabelWidth">
            <el-input v-model="form[6].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value8" :label-width="formLabelWidth">
            <el-input v-model="form[7].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
          <el-form-item label="value9" :label-width="formLabelWidth">
            <el-input v-model="form[8].value" class="w-50 m-2" autocomplete="off" />
          </el-form-item>
        </el-row>
      </el-form>

      <template #footer>
        <span class="dialog-footer">
          <el-button @click="hanlderClose">取消</el-button>
          <el-button type="primary" @click="handlerSure">确认</el-button>
        </span>
      </template>
    </el-dialog>
    <!--  -->

  </div>
  <script src="./heatmap.js"></script>
  <script>
    const { reactive, ref, onMounted, computed, watch, toRaw } = Vue

    const App = {
      name: "App",
      setup() {
        const rectInfo = reactive({
          width: (+window.getComputedStyle(document.body).width.replace(/px/, '')),
          height: (+window.getComputedStyle(document.body).height.replace(/px/, ''))
        })
        let form = reactive(initPoint())
        const dialogInput = ref(false)

        const heatMapContainer = ref(null)
        const gradientRef = ref(null)
        const minRef = ref(null)
        const maxRef = ref(null)

        let noise = getNoiseHelper();

        const data = computed(() => {
          const values = form.map(item => item.value)
          return {
            min: Math.min(...values),
            max: Math.max(...values),
            data: form
          }
        })
        const formLabelWidth = '80px'
        let heatMapInstance = undefined

        const canvasEl = document.createElement('canvas')
        const ctx = canvasEl.getContext("2d")
        ctx.translate(rectInfo.width / 2, rectInfo.height / 2)
        ctx.scale(1, -1)
        const legendCanvas = document.createElement('canvas')
        legendCanvas.width = 100;
        legendCanvas.height = 10;

        const legendCtx = legendCanvas.getContext('2d')
        let gradientCfg = {};

        // 生成数据
        function generateData() {
          let data = [];
          for (let i = 0; i <= rectInfo.width; i += 10) {
            for (let j = 0; j <= rectInfo.height; j += 10) {
              // let x = (max - min) * i / 200 + min;
              // let y = (max - min) * j / 100 + min;
              data.push({ x: i, y: j, value: noise.perlin2(i, j) + 70, radius: Math.random() * 100 + 20 });
              // data.push([i, j, normalDist(theta, x) * normalDist(theta, y)]);
            }
          }
          // console.log(data)
          return data;
        }
        // let temData = generateData(20, -5, 5);
        // console.log(temData)

        function handlerInput() {
          dialogInput.value = true
        }
        function hanlderClose() {
          dialogInput.value = false
        }
        function handlerSure() {
          heatMapInstance.setData(generate())
          dialogInput.value = false
        }

        function updateLegend(data) {
          minRef.value.innerHTML = data.min
          maxRef.value.innerHTML = data.max
          if (data.gradient != gradientCfg) {
            gradientCfg = data.gradient
            let gradient = legendCtx.createLinearGradient(0, 0, 100, 1)
            for (let key in gradientCfg) {
              gradient.addColorStop(key, gradientCfg[key])
            }

            legendCtx.fillStyle = gradient
            legendCtx.fillRect(0, 0, 100, 10)
            gradientRef.value.src = legendCanvas.toDataURL()
          }
        }

        // generate 1000 datapoints
        function generate() {
          // randomly generate extremas
          var extremas = [(Math.random() * 1000) >> 0, (Math.random() * 1000) >> 0];
          var max = Math.max.apply(Math, extremas);
          var min = Math.min.apply(Math, extremas);
          var t = [];
          for (var i = 0; i < 1000; i++) {
            var x = (Math.random() * rectInfo.width) >> 0;
            var y = (Math.random() * rectInfo.height) >> 0;
            var c = ((Math.random() * max - min) >> 0) + 50;
            // btw, we can set a radius on a point basis
            var r = (Math.random() * 80) >> 0;
            // add to dataset
            t.push({ x: x, y: y, value: c, radius: r });
          }
          return {
            min: min,
            max: max,
            // data: t
            data: generateData(200, 0, 100)
          }
        };

        function initPoint() {
          const width = rectInfo.width
          const height = rectInfo.height
          const xGap = Math.floor(width / 4)
          const yGap = Math.floor(height / 4)
          let res = []
          let x = 0;
          let y = 0;
          let index = 0;
          for (let i = 1; i < 4; i++) {
            for (let j = 1; j < 4; j++) {
              x = i * xGap
              y = j * yGap
              value = 100
              res.push({
                x: x,
                y: y,
                value: value,
                radius: 100,
              })
            }
          }
          return res
        }

        function getNoiseHelper() {
          class Grad {
            constructor(x, y, z) {
              this.x = x;
              this.y = y;
              this.z = z;
            }
            dot2(x, y) {
              return this.x * x + this.y * y;
            }
            dot3(x, y, z) {
              return this.x * x + this.y * y + this.z * z;
            }
          }
          const grad3 = [
            new Grad(1, 1, 0),
            new Grad(-1, 1, 0),
            new Grad(1, -1, 0),
            new Grad(-1, -1, 0),
            new Grad(1, 0, 1),
            new Grad(-1, 0, 1),
            new Grad(1, 0, -1),
            new Grad(-1, 0, -1),
            new Grad(0, 1, 1),
            new Grad(0, -1, 1),
            new Grad(0, 1, -1),
            new Grad(0, -1, -1)
          ];
          const p = [
            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
            36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
            234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
            88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
            134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
            1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
            116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
            124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
            47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
            108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
            242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
            239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
            141, 128, 195, 78, 66, 215, 61, 156, 180
          ];
          // To remove the need for index wrapping, double the permutation table length
          let perm = new Array(512);
          let gradP = new Array(512);
          // This isn't a very good seeding function, but it works ok. It supports 2^16
          // different seed values. Write something better if you need more seeds.
          function seed(seed) {
            if (seed > 0 && seed < 1) {
              // Scale the seed out
              seed *= 65536;
            }
            seed = Math.floor(seed);
            if (seed < 256) {
              seed |= seed << 8;
            }
            for (let i = 0; i < 256; i++) {
              let v;
              if (i & 1) {
                v = p[i] ^ (seed & 255);
              } else {
                v = p[i] ^ ((seed >> 8) & 255);
              }
              perm[i] = perm[i + 256] = v;
              gradP[i] = gradP[i + 256] = grad3[v % 12];
            }
          }
          seed(0);
          // ##### Perlin noise stuff
          function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
          }
          function lerp(a, b, t) {
            return (1 - t) * a + t * b;
          }
          // 2D Perlin Noise
          function perlin2(x, y) {
            // Find unit grid cell containing point
            let X = Math.floor(x),
              Y = Math.floor(y);
            // Get relative xy coordinates of point within that cell
            x = x - X;
            y = y - Y;
            // Wrap the integer cells at 255 (smaller integer period can be introduced here)
            X = X & 255;
            Y = Y & 255;
            // Calculate noise contributions from each of the four corners
            let n00 = gradP[X + perm[Y]].dot2(x, y);
            let n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
            let n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
            let n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);
            // Compute the fade curve value for x
            let u = fade(x);
            // Interpolate the four results
            return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
          }

          return {
            seed,
            perlin2
          };
        }


        onMounted(() => {
          heatMapInstance = h337.create({
            container: heatMapContainer.value,
            canvas: canvasEl,
            width: rectInfo.width,
            height: rectInfo.height,
            maxOpacity: 0.5,
            minOpacity: 0.1,
            radius: 100,
            blur: 1,
            onExtremaChange: function onExtremaChange(data) {
              data.min = 0
              data.max = 100
              updateLegend(data);
            }
          })
          heatMapInstance.setData(generate())
          // heatMapInstance.setData()
        })

        return {
          form,
          minRef,
          maxRef,
          rectInfo,
          gradientRef,
          dialogInput,
          handlerSure,
          hanlderClose,
          handlerInput,
          formLabelWidth,
          heatMapContainer
        }
      }
    }

    const app = Vue.createApp(App).use(ElementPlus).mount("#app")

  </script>
</body>

</html>